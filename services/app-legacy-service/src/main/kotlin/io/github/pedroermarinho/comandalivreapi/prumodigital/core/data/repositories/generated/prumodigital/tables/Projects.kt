/*
 * This file is generated by jOOQ.
 */
package prumodigital.tables

import org.jooq.Condition
import org.jooq.Field
import org.jooq.ForeignKey
import org.jooq.Identity
import org.jooq.Index
import org.jooq.InverseForeignKey
import org.jooq.Name
import org.jooq.Path
import org.jooq.PlainSQL
import org.jooq.QueryPart
import org.jooq.Record
import org.jooq.SQL
import org.jooq.Schema
import org.jooq.Select
import org.jooq.Stringly
import org.jooq.Table
import org.jooq.TableField
import org.jooq.TableOptions
import org.jooq.UniqueKey
import org.jooq.impl.DSL
import org.jooq.impl.Internal
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl
import prumodigital.Prumodigital
import prumodigital.indexes.IDX_PROJECTS_COMPANY_ID
import prumodigital.indexes.IDX_PROJECTS_PROJECT_STATUS_ID
import prumodigital.keys.DAILY_REPORTS__FK_DR_PROJECT
import prumodigital.keys.EMPLOYEE_PROJECT_ASSIGNMENTS__FK_EPA_PROJECT
import prumodigital.keys.PROJECTS_PKEY
import prumodigital.keys.PROJECTS_PUBLIC_ID_KEY
import prumodigital.keys.PROJECTS__FK_PROJECTS_STATUS
import prumodigital.keys.UQ_PROJECTS_COMPANY_CODE
import prumodigital.tables.DailyReports.DailyReportsPath
import prumodigital.tables.EmployeeProjectAssignments.EmployeeProjectAssignmentsPath
import prumodigital.tables.ProjectStatus.ProjectStatusPath
import prumodigital.tables.records.ProjectsRecord
import java.math.BigDecimal
import java.time.LocalDate
import java.time.LocalDateTime
import java.util.UUID
import kotlin.collections.Collection
import kotlin.collections.List

/**
 * Armazena informações sobre os projetos gerenciados.
 */
@Suppress("UNCHECKED_CAST")
open class Projects(
    alias: Name,
    path: Table<out Record>?,
    childPath: ForeignKey<out Record, ProjectsRecord>?,
    parentPath: InverseForeignKey<out Record, ProjectsRecord>?,
    aliased: Table<ProjectsRecord>?,
    parameters: Array<Field<*>?>?,
    where: Condition?,
) : TableImpl<ProjectsRecord>(
        alias,
        Prumodigital.PRUMODIGITAL,
        path,
        childPath,
        parentPath,
        aliased,
        parameters,
        DSL.comment("Armazena informações sobre os projetos gerenciados."),
        TableOptions.table(),
        where,
    ) {
    companion object {
        /**
         * The reference instance of <code>prumodigital.projects</code>
         */
        val PROJECTS: Projects = Projects()
    }

    /**
     * The class holding records for this type
     */
    override fun getRecordType(): Class<ProjectsRecord> = ProjectsRecord::class.java

    /**
     * The column <code>prumodigital.projects.id</code>.
     */
    val ID: TableField<ProjectsRecord, Int?> = createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "")

    /**
     * The column <code>prumodigital.projects.public_id</code>.
     */
    val PUBLIC_ID: TableField<ProjectsRecord, UUID?> = createField(DSL.name("public_id"), SQLDataType.UUID.nullable(false), this, "")

    /**
     * The column <code>prumodigital.projects.company_id</code>. FK para
     * company.companies(id), identificando a empresa principal responsável ou
     * proprietária do projeto.
     */
    val COMPANY_ID: TableField<ProjectsRecord, Int?> = createField(DSL.name("company_id"), SQLDataType.INTEGER.nullable(false), this, "FK para company.companies(id), identificando a empresa principal responsável ou proprietária do projeto.")

    /**
     * The column <code>prumodigital.projects.name</code>. Nome do projeto.
     */
    val NAME: TableField<ProjectsRecord, String?> = createField(DSL.name("name"), SQLDataType.VARCHAR(255).nullable(false), this, "Nome do projeto.")

    /**
     * The column <code>prumodigital.projects.code</code>. Código único do
     * projeto dentro da empresa.
     */
    val CODE: TableField<ProjectsRecord, String?> = createField(DSL.name("code"), SQLDataType.VARCHAR(50).nullable(false), this, "Código único do projeto dentro da empresa.")

    /**
     * The column <code>prumodigital.projects.address_id</code>. FK opcional
     * para public.addresses(id), indicando o local físico principal do projeto.
     */
    val ADDRESS_ID: TableField<ProjectsRecord, Int?> = createField(DSL.name("address_id"), SQLDataType.INTEGER, this, "FK opcional para public.addresses(id), indicando o local físico principal do projeto.")

    /**
     * The column <code>prumodigital.projects.planned_start_date</code>. Data de
     * início planejada para o projeto.
     */
    val PLANNED_START_DATE: TableField<ProjectsRecord, LocalDate?> = createField(DSL.name("planned_start_date"), SQLDataType.LOCALDATE, this, "Data de início planejada para o projeto.")

    /**
     * The column <code>prumodigital.projects.planned_end_date</code>. Data de
     * término planejada para o projeto.
     */
    val PLANNED_END_DATE: TableField<ProjectsRecord, LocalDate?> = createField(DSL.name("planned_end_date"), SQLDataType.LOCALDATE, this, "Data de término planejada para o projeto.")

    /**
     * The column <code>prumodigital.projects.actual_start_date</code>. Data de
     * início real do projeto.
     */
    val ACTUAL_START_DATE: TableField<ProjectsRecord, LocalDate?> = createField(DSL.name("actual_start_date"), SQLDataType.LOCALDATE, this, "Data de início real do projeto.")

    /**
     * The column <code>prumodigital.projects.actual_end_date</code>. Data de
     * término real do projeto.
     */
    val ACTUAL_END_DATE: TableField<ProjectsRecord, LocalDate?> = createField(DSL.name("actual_end_date"), SQLDataType.LOCALDATE, this, "Data de término real do projeto.")

    /**
     * The column <code>prumodigital.projects.client_name</code>. Nome do
     * cliente para o qual o projeto está sendo executado, se aplicável.
     */
    val CLIENT_NAME: TableField<ProjectsRecord, String?> = createField(DSL.name("client_name"), SQLDataType.VARCHAR(255), this, "Nome do cliente para o qual o projeto está sendo executado, se aplicável.")

    /**
     * The column <code>prumodigital.projects.project_status_id</code>. FK para
     * prumodigital.project_status(id), indicando o status atual do projeto.
     */
    val PROJECT_STATUS_ID: TableField<ProjectsRecord, Int?> = createField(DSL.name("project_status_id"), SQLDataType.INTEGER.nullable(false), this, "FK para prumodigital.project_status(id), indicando o status atual do projeto.")

    /**
     * The column <code>prumodigital.projects.budget</code>. Orçamento estimado
     * ou alocado para o projeto.
     */
    val BUDGET: TableField<ProjectsRecord, BigDecimal?> = createField(DSL.name("budget"), SQLDataType.NUMERIC(15, 2), this, "Orçamento estimado ou alocado para o projeto.")

    /**
     * The column <code>prumodigital.projects.description</code>. Descrição
     * detalhada do escopo e objetivos do projeto.
     */
    val DESCRIPTION: TableField<ProjectsRecord, String?> = createField(DSL.name("description"), SQLDataType.CLOB, this, "Descrição detalhada do escopo e objetivos do projeto.")

    /**
     * The column <code>prumodigital.projects.created_at</code>.
     */
    val CREATED_AT: TableField<ProjectsRecord, LocalDateTime?> = createField(DSL.name("created_at"), SQLDataType.LOCALDATETIME(6).nullable(false).defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.LOCALDATETIME)), this, "")

    /**
     * The column <code>prumodigital.projects.updated_at</code>.
     */
    val UPDATED_AT: TableField<ProjectsRecord, LocalDateTime?> = createField(DSL.name("updated_at"), SQLDataType.LOCALDATETIME(6).nullable(false).defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.LOCALDATETIME)), this, "")

    /**
     * The column <code>prumodigital.projects.deleted_at</code>.
     */
    val DELETED_AT: TableField<ProjectsRecord, LocalDateTime?> = createField(DSL.name("deleted_at"), SQLDataType.LOCALDATETIME(6), this, "")

    /**
     * The column <code>prumodigital.projects.created_by</code>.
     */
    val CREATED_BY: TableField<ProjectsRecord, String?> = createField(DSL.name("created_by"), SQLDataType.VARCHAR(255), this, "")

    /**
     * The column <code>prumodigital.projects.updated_by</code>.
     */
    val UPDATED_BY: TableField<ProjectsRecord, String?> = createField(DSL.name("updated_by"), SQLDataType.VARCHAR(255), this, "")

    /**
     * The column <code>prumodigital.projects.version</code>.
     */
    val VERSION: TableField<ProjectsRecord, Int?> = createField(DSL.name("version"), SQLDataType.INTEGER.defaultValue(DSL.field(DSL.raw("1"), SQLDataType.INTEGER)), this, "")

    private constructor(alias: Name, aliased: Table<ProjectsRecord>?) : this(alias, null, null, null, aliased, null, null)
    private constructor(alias: Name, aliased: Table<ProjectsRecord>?, parameters: Array<Field<*>?>?) : this(alias, null, null, null, aliased, parameters, null)
    private constructor(alias: Name, aliased: Table<ProjectsRecord>?, where: Condition?) : this(alias, null, null, null, aliased, null, where)

    /**
     * Create an aliased <code>prumodigital.projects</code> table reference
     */
    constructor(alias: String) : this(DSL.name(alias))

    /**
     * Create an aliased <code>prumodigital.projects</code> table reference
     */
    constructor(alias: Name) : this(alias, null)

    /**
     * Create a <code>prumodigital.projects</code> table reference
     */
    constructor() : this(DSL.name("projects"), null)

    constructor(path: Table<out Record>, childPath: ForeignKey<out Record, ProjectsRecord>?, parentPath: InverseForeignKey<out Record, ProjectsRecord>?) : this(Internal.createPathAlias(path, childPath, parentPath), path, childPath, parentPath, PROJECTS, null, null)

    /**
     * A subtype implementing {@link Path} for simplified path-based joins.
     */
    open class ProjectsPath :
        Projects,
        Path<ProjectsRecord> {
        constructor(path: Table<out Record>, childPath: ForeignKey<out Record, ProjectsRecord>?, parentPath: InverseForeignKey<out Record, ProjectsRecord>?) : super(path, childPath, parentPath)
        private constructor(alias: Name, aliased: Table<ProjectsRecord>) : super(alias, aliased)

        override fun `as`(alias: String): ProjectsPath = ProjectsPath(DSL.name(alias), this)

        override fun `as`(alias: Name): ProjectsPath = ProjectsPath(alias, this)

        override fun `as`(alias: Table<*>): ProjectsPath = ProjectsPath(alias.qualifiedName, this)
    }

    override fun getSchema(): Schema? = if (aliased()) null else Prumodigital.PRUMODIGITAL

    override fun getIndexes(): List<Index> = listOf(IDX_PROJECTS_COMPANY_ID, IDX_PROJECTS_PROJECT_STATUS_ID)

    override fun getIdentity(): Identity<ProjectsRecord, Int?> = super.getIdentity() as Identity<ProjectsRecord, Int?>

    override fun getPrimaryKey(): UniqueKey<ProjectsRecord> = PROJECTS_PKEY

    override fun getUniqueKeys(): List<UniqueKey<ProjectsRecord>> = listOf(PROJECTS_PUBLIC_ID_KEY, UQ_PROJECTS_COMPANY_CODE)

    override fun getReferences(): List<ForeignKey<ProjectsRecord, *>> = listOf(PROJECTS__FK_PROJECTS_STATUS)

    private lateinit var _projectStatus: ProjectStatusPath

    /**
     * Get the implicit join path to the
     * <code>prumodigital.project_status</code> table.
     */
    fun projectStatus(): ProjectStatusPath {
        if (!this::_projectStatus.isInitialized) {
            _projectStatus = ProjectStatusPath(this, PROJECTS__FK_PROJECTS_STATUS, null)
        }

        return _projectStatus
    }

    val projectStatus: ProjectStatusPath
        get(): ProjectStatusPath = projectStatus()

    private lateinit var _dailyReports: DailyReportsPath

    /**
     * Get the implicit to-many join path to the
     * <code>prumodigital.daily_reports</code> table
     */
    fun dailyReports(): DailyReportsPath {
        if (!this::_dailyReports.isInitialized) {
            _dailyReports = DailyReportsPath(this, null, DAILY_REPORTS__FK_DR_PROJECT.inverseKey)
        }

        return _dailyReports
    }

    val dailyReports: DailyReportsPath
        get(): DailyReportsPath = dailyReports()

    private lateinit var _employeeProjectAssignments: EmployeeProjectAssignmentsPath

    /**
     * Get the implicit to-many join path to the
     * <code>prumodigital.employee_project_assignments</code> table
     */
    fun employeeProjectAssignments(): EmployeeProjectAssignmentsPath {
        if (!this::_employeeProjectAssignments.isInitialized) {
            _employeeProjectAssignments = EmployeeProjectAssignmentsPath(this, null, EMPLOYEE_PROJECT_ASSIGNMENTS__FK_EPA_PROJECT.inverseKey)
        }

        return _employeeProjectAssignments
    }

    val employeeProjectAssignments: EmployeeProjectAssignmentsPath
        get(): EmployeeProjectAssignmentsPath = employeeProjectAssignments()

    override fun `as`(alias: String): Projects = Projects(DSL.name(alias), this)

    override fun `as`(alias: Name): Projects = Projects(alias, this)

    override fun `as`(alias: Table<*>): Projects = Projects(alias.qualifiedName, this)

    /**
     * Rename this table
     */
    override fun rename(name: String): Projects = Projects(DSL.name(name), null)

    /**
     * Rename this table
     */
    override fun rename(name: Name): Projects = Projects(name, null)

    /**
     * Rename this table
     */
    override fun rename(name: Table<*>): Projects = Projects(name.qualifiedName, null)

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Condition?): Projects = Projects(qualifiedName, if (aliased()) this else null, condition)

    /**
     * Create an inline derived table from this table
     */
    override fun where(conditions: Collection<Condition>): Projects = where(DSL.and(conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(vararg conditions: Condition?): Projects = where(DSL.and(*conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Field<Boolean?>?): Projects = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(condition: SQL): Projects = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(
        @Stringly.SQL condition: String,
    ): Projects = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(
        @Stringly.SQL condition: String,
        vararg binds: Any?,
    ): Projects = where(DSL.condition(condition, *binds))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(
        @Stringly.SQL condition: String,
        vararg parts: QueryPart,
    ): Projects = where(DSL.condition(condition, *parts))

    /**
     * Create an inline derived table from this table
     */
    override fun whereExists(select: Select<*>): Projects = where(DSL.exists(select))

    /**
     * Create an inline derived table from this table
     */
    override fun whereNotExists(select: Select<*>): Projects = where(DSL.notExists(select))
}
